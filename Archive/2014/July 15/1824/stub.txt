JLJac
91

Yep, that&#039;s true. The thought crossed me that each segment of a corridor could be made to one big, rectangular cell, or similar solutions. In the end I decided to keep to this solution as the connections between different tiles are on the tile level, and because the path finder is not only supposed to be able to find a legal path to a legal position, but also the closest you can get to an illegal position. If you were to only map the corners, or some similar solution, it would be kind of unclear how mapping illegal space should tie into that, which is why I&#039;ve kept it simple. But if performance issues start to pop up, I&#039;ll definitely reconsider it!<br><br><b>Update 272</b><br>Sorry guys, this is not gonna be an exciting one. <br><br>Averted a number of null reference exceptions that would happen because some coordinates were not properly migrated from tile space to node space on exiting a room. <br><br>Changed it so that instead of connecting a tile of the realized room to a node in the next room through an exit, the tile is connected to the node in the same room, which is then in turn connected to the next room. Ie it doesn&#039;t bypass nodes in the realized room any more, which is cool for a number of reasons, one of which is that it&#039;ll help later when I come to giving creatures cozy little holes to crawl down and hibernate in.<br><br>Moved the quick connectivity mapper to a static class, making it accessible from everywhere. <br><br>When deciding which exit a coordinate is closest to, in order to convert it to node space, I check both if it&#039;s possible to get from the coordinate to the exit <i>and </i>vice versa, hopefully giving a slightly better representation of tile coordinates in node space.<br><br>Etc etc etc.<br><br>Basically I&#039;ve been cleaning stuff up. I tend towards working like that - first I just go in there and massacre the problems in whatever way possible, then I go over the solution and tidy it up. By now I think the path finding is actually solid enough to start moving on to either embryonic AI (keeping track of where I want to go, having a few modes of behavior to finite-state-machine between) or abstract creatures (creatures in a super-simplified state as they are outside of the currently loaded world), perhaps both. Abstract creatures also need <i>some </i>AI, such as a basic idea about &quot;where am I going?&quot; and &quot;what am I doing?&quot; to be able to know if the current behavior is &quot;hunting&quot; or &quot;retreating to hole because of approaching rain&quot;. For this reason it might actually make the most sense to have these two next problems be one, and integrate the most basic aspects of AI with the super simplified creature. 