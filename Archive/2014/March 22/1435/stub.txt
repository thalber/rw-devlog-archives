JLJac
71

<div class="quoteheader"><a href="https://web.archive.org/web/20150101015922/http://forums.tigsource.com/index.php?topic=25183.msg1006834#msg1006834">Quote from: Bandreus on March 20, 2014, 11:52:52 AM</a></div><div class="quote">The real reason I don&#039;t like to use getters/setters is code bloat and the fact those are one easy step into overengineering of classes/engine architecture.<br><br>I never seriously coded anything in C#, but the performance-impact should be similar to what it is in most OO languages. I.e. barely noticeable at all (again, unless in performance critical code, where squeezing out every additional millisecond could actually matter).<br><br>So don&#039;t overthink these sort of things too much, just roll with whatever you feel most comfortable with and get a feel for whatever you&#039;re using while you&#039;ve your hands right into it&nbsp; <img src="https://web.archive.org/web/20150101015922im_/http://forums.tigsource.com/Smileys/derek/hand-thumbsup-l.gif" alt="Hand Thumbs Up Left" border="0"><br></div><br>Thanks! I will <img src="https://web.archive.org/web/20150101015922im_/http://forums.tigsource.com/Smileys/derek/smiley.gif" alt="Smiley" border="0"><br>Actually I have found something that seems pretty annoying with getters/setters, almost to the point where I&#039;m considering not using them. It seems that for a compound variable or whatever you want to call it, such as a vector, you can&#039;t set the sub-varaibles individually. For example I can&#039;t do this:<br><div class="codeheader">Code:</div><div class="code">bodyChunk.position.x = 5.5f;<br></div>because it will give me an error message. Instead I have to do this:<br><div class="codeheader">Code:</div><div class="code">bodyChunk.position = new Vector2(5.5f, bodyChunk.position.y);<br></div>which is longer, harder to read, generally clunkier and totally rubs me the wrong way with my &quot;it feels like I&#039;m declaring new Vector2&#039;s everywhere, that can&#039;t be good&quot;-complex.<br><br><div class="quoteheader"><a href="https://web.archive.org/web/20150101015922/http://forums.tigsource.com/index.php?topic=25183.msg1006828#msg1006828">Quote from: NicoM on March 20, 2014, 11:47:52 AM</a></div><div class="quote">One great real world use for properties, is to use them to (for instance) only up a speed variable if it is less than a maximum, otherwise set it to the maximum<br></div>This seems totally valid though! In theory I could use a Mathf.Clamp every time I set the value to achieve the same result, but if I want to change the max or min of that clamp, I&#039;ll be happy if I used a property :S<br><br><b>Update 222</b><br>Quite a lot has happened! A basic &quot;creature&quot; (two dots) is in the game. I have the very basics of how a rain world creature works up and running, and this time around I have a much more general and slick framework for it. Basically a creature (or physical object, at the very top of the inheritance tree) consists of a number of BodyChunks, and a number of BodyChunkConnections. The former is the standard unit that builds bodies and moves about with classic newtonian physics, colliding with walls and each other. The latter is the internal bonds that hold the BodyChunks of a specific creature together, so they don&#039;t drift apart. <br><br>Basic terrain collision is in, but I&#039;m not sure how well it works at this point because I haven&#039;t yet set up tools to test it properly. It&#039;s able to keep an object that moves around with random forces applied within the level boundries, so that&#039;s something. At this point it&#039;s a straight port from the old rain world code, but I think I&#039;ll go over it an re-think parts of it that are a bit whacky. It&#039;s certainly a huge help to have a template to look at when coding though. I don&#039;t have to invent the wheel, merely make it roll.<br><br>What I&#039;m most proud of though, is my camera system. In previous games, I&#039;ve always had a fairly standard approach to how I do rendering. When an object is created, it asks some kind of sprite engine for a couple of sprites. Then it stores them in a list, and each frame move them around. When deleted, it returns them to the sprite engine or deletes them. <br><br>Not this time around! My starting point was this - objects shouldn&#039;t be responsible for being visible, they should just exist, and instead there should be a camera <i>viewing </i>them. Instead of having objects take care of their individual sprites, they should just take care of their behaviours, and the sprites should be handled by a self contained camera object. They shouldn&#039;t even know they&#039;re being watched.<br><br>Why do I want this? Because in the old game, the level you were viewing was the only one that existed. I tried to fake a bit of off-screen movement, but it wasn&#039;t the real deal. This time I want to make everything completely independent on whether it&#039;s being watched. The world should just exist, and the camera should be a ghost moving around watching it. The other big thing is that if I get Futile to work with unity&#039;s split screen, I could have two cameras viewing the same game world.<br><br>So this is the way I do this: Objects sign up to an IDrawable interface which contains an initiate method and a draw method. The Room has a DrawableObjects list, which contains all objects signed up to that interface. The Camera is assigned to watching a specific Room.<br><br>Inside the Camera, there&#039;s a sub-class (is that the term? A class defined within another class) called SpriteLeaser. My english wasn&#039;t really sufficient to come up with a good name for this thing, but basically it lends sprites to an object. It consists of only an array of sprites, a reference to an object and a &quot;remove me&quot; flag.<br><br>Say that the Camera changes rooms. Now it goes through all the drawables of the new room, and for each of them it creates a SpriteLeaser. The SpriteLeaser calls the object&#039;s initiate method, passes itself as a parameter, and says &quot;Hi, I&#039;m a SpriteLeaser at your service!&quot; The object is like &quot;Cool, I&#039;m a Slugcat so I&#039;m gonna need 12 sprites, this sprite should have this graphic, this sprite should have that graphic...&quot; etc. <br><br>The next frame, the Camera will get its Update method called. Then it will go through all of its SpriteLeasers, and tell each of them to contact their respective objects through the Draw method, once again with themselves passed as a parameter. The object will rearrange the sprites according to its new position, and if it&#039;s slated for removal or in another room than the camera, it will also tell the SpriteLeaser to slate itself for removal. <br><br>The thing here is that the objects are passive. They don&#039;t take care of sprites, the just passively respond to the initiate and draw commands. If the camera moves to another room, the object won&#039;t even notice. It doesn&#039;t have to do anything, it just stops recieving the Draw commands, which are completely separate from all other code. <br><br>This was the best solution I could come up with for a self-contained camera and a world that goes about its behaviours with or without being watched. I know I&#039;m probably re-inveting the wheel, but it was really fun doing it! <img src="https://web.archive.org/web/20150101015922im_/http://forums.tigsource.com/Smileys/derek/smiley.gif" alt="Smiley" border="0">