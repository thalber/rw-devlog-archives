JLJac
99

@Gimym JIMBERT, Thanks for links! Yeah, a mix of those solutions is basically what I&#039;ve been thinking about as well. Just wanted to make sure that there wasn&#039;t a super obvious go-to solution I was missing here!<br><br><b>Update 304</b><br>Today was spent in <i>thinking mode</i>. <br><br><img src="https://web.archive.org/web/20141228135533im_/http://imgwiz.com/images/2014/09/10/weCO6.jpg" alt="" border="0"><br><br>I&#039;ve been able to outline a few methods for keeping distance from threats - I think I could make something work that would be an approximation of an occupancy map setup. Creatures can&#039;t share these, as they all have different ideas of where all the other creatures are, so they&#039;d have to be rather optimized as many creature might be updating them often. My idea is some sort of heuristic version that for the most part just uses 2D distance (getting away to the other end of the map is rarely a bad idea) but very close to the creature can overlay this with a small dijkstra map for some smarter behavior when it comes to walls.<br><br>The main issue though is the question of how to avoid dead ends and corners. I think this is going to be the main factor in whether or not the behavior will look decently intelligent - running straight into the closest corner is going to look dumb. After some contemplation I came up with this: What is a dead end? It is <i>not </i>a loop. A loop in this case being a group of allowed tiles that encircles a group of unallowed tiles.<br><br><img src="https://web.archive.org/web/20141228135533im_/http://imgwiz.com/images/2014/09/10/Ix47.png" alt="" border="0"><br><br>A real scenario might not be as black and white as this, for example I don&#039;t think most people would consider a big open room a &quot;dead end&quot;. But let&#039;s not give any benefits of doubt here - for simplicity, let&#039;s write off everything not a loop as a dead end. The purpose will still be served - if you can get to one of these loops, you will at least have the benefit of being able to run away for ever rather than ending up with nowhere to go.<br><br>Especially places where many loops intersect would be attractive in a fleeing scenario. Imagine the center point in the character &quot;8&quot;. That&#039;s two loops intersecting - if you&#039;re a paranoid creature fleeing from foes and you&#039;re in an 8-shaped room, you&#039;d probably default to that center point where you have the most options for escape to pick from, right?<br><br>So, how do I find loops? The first thing I though was that I&#039;d identify every continuous blob of unallowed tiles using <a href="https://web.archive.org/web/20141228135533/http://en.wikipedia.org/wiki/Connected-component_labeling" target="_blank">connected component labeling</a>.<br><br>When I&#039;d found every such shape, I&#039;d let all of them grow at an even pace into the allowed tiles, until they hit each other. Those edges would be the loops.<br><br><img src="https://web.archive.org/web/20141228135533im_/http://imgwiz.com/images/2014/09/10/40zsS.gif" alt="" border="0"><br><br><br>I was really enthusiastic about this approach for a while, but then I realized that my path finding map isn&#039;t that simple. For example I have connections that are valid one way but not the other, and connections that takes the creature across unallowed tiles, messing up the blob integrity completely. These shapes of unallowed tiles probably <i>could </i>be defined still, but they&#039;d be multi-dimensional objects that I wouldn&#039;t have a chance against. <br><br><img src="https://web.archive.org/web/20141228135533im_/http://imgwiz.com/images/2014/09/10/kqMyt.jpg" alt="" border="0"><br><br>So what I&#039;m thinking about now is a slightly different approach. I&#039;ll map the allowed areas instead, using a dijkstra&#039;s algorithm-like method (essentially a flood fill where you keep track of where each tile was filled <i>from</i>). <br><br>When filling the tiles, if I encounter a tile that&#039;s already filled, I do a common ancestor check. As all the tiles are filled from one original tile, and the dijkstra method keeps track of the &quot;parent&quot; of each new filled tile, you essentially have an ancestry tree. If I&#039;m in one branch of that tree, and collide with another branch, I can check how far back these branches have a common ancestor. If that&#039;s not long ago, they are basically siblings, part of the same &quot;frontier&quot; filling in an area. If their ancestor is far back though, that means that we have a loop!<br><br>By moving from the collision point to the common ancestor through both branches, the loop can be identified tile by tile. <br><br><img src="https://web.archive.org/web/20141228135533im_/http://imgwiz.com/images/2014/09/10/GtKTn.png" alt="" border="0"><br><br>What do you think? Is it going to fail for some obvious reason?