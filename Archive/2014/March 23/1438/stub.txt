JLJac
71

That&#039;s totally true! I&#039;ve been contemplating quite a lot on this stuff, and I really would like to have some kind of general system, because as you say, players and pups share a lot of behaviours.<br><br><b>Update 223</b><br>But, hehe, listen to this... So I created this really cool (IMO) finite state machine. It consists of a base class for PlayerAnimations, which has an initiate and an update method, and a lot of derived classes such as PlayerAnimationStandUp etc. It also had an enum with all the animations. <br>And an array PlayerAnimation&#91;] animations. The array holds an instance of each animation derived class (as eigenbom suggested, they&#039;re all alive simultaneously) and the enum is used to map to the array positions, so it&#039;s possible to change the state using a name rather than a weird number.<br><br><div class="codeheader">Code:</div><div class="code"><span style="white-space: pre;"> </span><br><span style="white-space: pre;"> </span>//Array which holds an instance of each state class<br><span style="white-space: pre;"> </span>public PlayerAnimation&#91;] animations;<br><br><span style="white-space: pre;"> </span>//Enum for all the animation states<br><span style="white-space: pre;"> </span>public enum AnimationIndex<br><span style="white-space: pre;"> </span>{<br><span style="white-space: pre;"> </span><span style="white-space: pre;"> </span>None,<br><span style="white-space: pre;"> </span><span style="white-space: pre;"> </span>CrawlTurn,<br><span style="white-space: pre;"> </span><span style="white-space: pre;"> </span>StandUp,<br><span style="white-space: pre;"> </span><span style="white-space: pre;"> </span>DownOnFours,<br><span style="white-space: pre;"> </span><span style="white-space: pre;"> </span>LedgeCrawl,<br><span style="white-space: pre;"> </span><span style="white-space: pre;"> </span>HangFromBeam,<br><span style="white-space: pre;"> </span><span style="white-space: pre;"> </span>GetUpOnBeam,<br><span style="white-space: pre;"> </span><span style="white-space: pre;"> </span>StandOnBeam,<br><span style="white-space: pre;"> </span><span style="white-space: pre;"> </span>ClimbOnBeam,<br><span style="white-space: pre;"> </span><span style="white-space: pre;"> </span>BeamTip,<br><span style="white-space: pre;"> </span><span style="white-space: pre;"> </span>Dead<br><span style="white-space: pre;"> </span>}<br><span style="white-space: pre;"> </span>public AnimationIndex animation{ get; private set; }<br><br>&nbsp; &nbsp; &nbsp; &nbsp; //Changes the Animation<br><span style="white-space: pre;"> </span>public void ChangeAnimation (AnimationIndex anIndx)<br><span style="white-space: pre;"> </span>{<br><span style="white-space: pre;"> </span><span style="white-space: pre;"> </span>animation = anIndx;<br><span style="white-space: pre;"> </span><span style="white-space: pre;"> </span>animations [(int)anIndx].Initiate ();<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;}<br><br><span style="white-space: pre;"> </span>public void Update ()<br><span style="white-space: pre;"> </span>{<br><span style="white-space: pre;"> </span><span style="white-space: pre;"> </span>animations [(int)animation].Update ();<br><span style="white-space: pre;"> </span>}<br></div>Like this, see? When setting the animations I could use the AnimationIndex enum, and get the names through auto complete, by just mapping the enum to an integer and making sure that a given enum leads to the right animation instance in the array.<br><br>Super cool!<br><br>But.<br><br>Thing #1. No inheritance. I did think long and hard about how I could create inheritance so I could have a general FSM class to inherit from everywhere I needed this behaviour, but what would that class contain? Not the enum, that has to be declared specifically for each implementation. Not the array of states, same goes for that. Basically the only thing I could inherit would be some sort of base class for the states. Almost everything in this solution has to be written again each time I applied this solution.<br><br>And Thing #2. This whole elaborate solution does nothing that a switch case doesn&#039;t do. Except occupy more memory, being clunkier, and involving more properties. And being unable to access the privates of the owner object because it&#039;s its own class. The only thing it has on the switch case would be being able to run initiate methods for each state, but I don&#039;t have any functionality like that, and if I needed to I could just run a generic init method with its own switch statement in it. <br><br>Conclusion: The coolest and most elaborate solution might not be the best. Here I really tried for an elegant solution, and ended up creating the opposite. Instead, I&#039;ve found the <i>partial </i>keyword, which allows me to split a class over several text files. So I&#039;m going to go ahead and scrap that fancy FSM, and just create a big, fat switch statement insrtead <img src="https://web.archive.org/web/20150101015922im_/http://forums.tigsource.com/Smileys/derek/smiley.gif" alt="Smiley" border="0"> 