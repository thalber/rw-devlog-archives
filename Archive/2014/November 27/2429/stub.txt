JLJac
121

<b>Update 365</b><br>Item placement in the world... Made it so that the level editor saves item placements, and the game then puts the items in the level. The system isn&#039;t entirely done yet, as it can&#039;t differentiate between rocks and spears. What I have been able to finish is some re-working of the entity ID stuff. The reason this was needed was that for items, I wanted to be able to delete the item entirely, and re-create it, having the game still be aware that it&#039;s the same item.<br><br>My solution for this was to assign items ID&#039;s based in their placement in the world. So the item ID is just an integer that&#039;s 10 000 times the room index, plus the item placement in the room. I calculated that the 32 bit integer range should be larger than 10 000^2, meaning that the system would allow for ten thousand rooms with ten thousand items in each without mixing them up. Am I correct? <br><br>Then the ID <i>also </i>has the old system running in separate, which just ticks up as new objects are instantiated, and for an ID comparison to return true both the &quot;original spawn location number&quot; and the &quot;ticking upwards number&quot; have to match, meaning that the game can&#039;t mistake some spear for some bat or something because of random chance.<br><br>Ok, so why create this elaborate system? The idea is that now I don&#039;t have to save the position of every rock and spear in the entire world, I can just save the fact that they&#039;re moved when they&#039;re moved. The system works like this~<br><br>As a room is realized, it goes by all the rocks and spears that are supposedly in that room. It creates an instance for each of them, giving that instance an ID based on the spawn position. Then it adds them all to a global Misplaced Items list.<br><br>When the room is again abstracted, it checks all the items in the room - from the item&#039;s ID it can calculate the item&#039;s supposed spawn position. If the item <i>is </i>on its spawn position, the item is removed from the Misplaced Items list, and then the instance is removed as well. But say one item has moved, a spear picked up by the player. As that one isn&#039;t on its correct spot, it will remain on the Misplaced Items list. The room is then unloaded.<br><br>Later the same room is loaded again. As it goes by the items that should spawn in the room, it checks the missing items list for each one of them. The spear is on there! So the spear is <i>not </i>placed in the room. Instead, the game is keeping track of the spear somewhere else. <br><br>There&#039;s one of each item, and only one, but always one! At least that&#039;s the idea, after all the bugs have been squashed. The cool thing is that as the random seed for the items&#039; look is based on the ID, the same item will always look the same. <br><br>Other than that, I&#039;ve done a little bit more of lizard behavior cleanup. It really gets to me not being able to save and load the state of a lizard. Whenever they do some buggy behavior, I have to guess what they&#039;re doing, and then guess the solution, and then hope that whatever I did actually solved it. In the lingo environment (which was worse in every other way, but this one thing was cool) I could save every variable in a lizard object to a text file, meaning that when I saw a lizard doing something stupid I could hit a button to save that stupidity, and then have that little moment captured. I could then load it and diagnose it, and mess with it until it worked again. Really nice!<br><br>I know that in theory I could do that here too, if I made the lizard class serializable. Problem is that last time I tried serialization, every object that was referenced by the serialized object also had to be serializable. And my game is super interconnected, so I see no way of accomplishing that without making exactly everything serializable, and just save the entire game state.<br><br>Maybe that&#039;s a good idea? Is that how quick save works? Is there some quick way of trying that out, that doesn&#039;t mean pasting [Serializable] in every single class?