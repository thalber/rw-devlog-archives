JLJac
149

@prinsessa, actually rather than digging up the paper it&#039;s considerably easier for me to just post my source code for the water stuff, so here you go! Might help out some other people too:<br><br><br>&nbsp;&nbsp; &nbsp;<br><br><div class="codeheader">Code:</div><div class="code">public class Water(){<br>//These are the parameters used by the surface simulation. Expect to spend at least a day tuning them haha<br>&nbsp;&nbsp; &nbsp; float &nbsp; dx = 0.0005f * 20f;<br>&nbsp;&nbsp; &nbsp; float &nbsp; dt = 0.0045f;<br>&nbsp;&nbsp; &nbsp; float &nbsp; C = 1f;<br>&nbsp;&nbsp; &nbsp; float &nbsp; R = C * dt / dx;<br><br><br>&nbsp;&nbsp; &nbsp; surface = new SurfacePoint[100];<br>&nbsp;&nbsp; &nbsp; for(int i = 0; i &lt; surface.Length; i++)<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; surface[i] = new SurfacePoint();<br>}<br><br><br>public class SurfacePoint<br>{<br>&nbsp;&nbsp; height = 0f;<br>&nbsp;&nbsp; lastHeight = 0f;<br>&nbsp;&nbsp; nextHeight = 0f;<br>&nbsp;&nbsp; public SurfacePoint()<br>&nbsp;&nbsp; {<br>&nbsp;&nbsp; }<br>}<br><br>public Update(){<br>&nbsp;float averageHeight = 0f;<br><br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;for (int i = 0; i &lt; surface.Length; i++) {<br><br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//This here is the fancy math from the paper, which I don&#039;t claim to understand in the slightest :P<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (i == 0) { //special case first point<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;surface[i].nextHeight =<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(2f * surface[i].height + (R - 1f) * surface[i].lastHeight +<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2f * Mathf.Pow(R, 2f) *<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(surface[i + 1].height - surface[i].height)) / (1f + R);<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;else if (i == surface.Length - 1) { //special case last point<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;surface[i, 0].nextHeight =<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(2f * surface[i].height + (R - 1f) * surface[i].lastHeight +<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2f * Mathf.Pow(R, 2f) *<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(surface[i - 1].height - surface[i].height)) / (1f + R);<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;else {<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;surface[i].nextHeight = Mathf.Pow(R, 2f)<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * (surface[i - 1].height + surface[i + 1].height)<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; + 2f * (1f - Mathf.Pow(R, 2f))<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * surface[i].height - surface[i].lastHeight;<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br><br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;surface[i].nextHeight *= 0.99f; //points should slowly tend towards 0, or the water level will change over time<br><br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;averageHeight += surface[i].height;<br><br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;}<br><br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;averageHeight /= surface.Length; <br><br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;for (int i = 0; i &lt; surface.Length; i++) {<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;surface[i].lastHeight = surface[i].height; //This line here is the necessary line. Below is some stuff I came up with to stabilize the system, it tended to flip out in some scenarios<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;float h = surface[i].nextHeight - averageHeight;<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (i &gt; 0 &amp;&amp; i &lt; surface.Length - 1) h = Mathf.Lerp(h, Mathf.Lerp(surface[i - 1].nextHeight, surface[i + 1].nextHeight, 0.5f), 0.01f);<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;surface[i].height = Mathf.Clamp(h, -40f, 40f);<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;}<br>}</div>