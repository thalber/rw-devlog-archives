JLJac
227

@JobLeonard, your sketch illustrates the method I use nicely <img src="https://web.archive.org/web/20150831160950im_/http://forums.tigsource.com/Smileys/derek/smiley.gif" alt="Smiley" border="0"> I don&#039;t see the need for the convex hull though - I just use a line/vector distance to check which point that the rope hit first (on your sketch that top left one) and because that point will be convex and far out from the middle, it&#039;ll be one of the convex hull vertices either way, without having to explicitly calculate it. The concave points (such as the one in that crevice on the shape in your sketch) there&#039;s really no reason to bother with at all, because as long as the tips of the rope have terrain collision those can never end up inside a sweep.<br><br>@Christian, TheWing, yep, 45 unless you hold up, then straight up. And a little bit of auto aim - if the original aim direction seems to be all empty of terrain it&#039;ll check a few angles to the sides as well and see if any of those hit something.<br><br>@Paul, wow yeah, that looks super similar! Let me know what was and wasn&#039;t the same in the code!<br><br><div class="codeheader">Code:</div><div class="code">public class Rope<br>{<br>&nbsp; &nbsp; public Room room;<br>&nbsp; &nbsp; public Vector2 A, B, lastA, lastB;<br>&nbsp; &nbsp; public float totalLength;<br>&nbsp; &nbsp; public List&lt;Corner&gt; bends;<br>&nbsp; &nbsp; float thickness;<br><br>&nbsp; &nbsp; public RopeDebugVisualizer visualizer;<br>&nbsp; &nbsp; public List&lt;Corner&gt; corners;<br><br>&nbsp; &nbsp; public Vector2 AConnect<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; get<br>&nbsp; &nbsp; &nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (bends.Count == 0) return B;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else return bends[0].pos;<br>&nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; }<br>&nbsp; &nbsp; public Vector2 BConnect<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; get<br>&nbsp; &nbsp; &nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (bends.Count == 0) return A;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else return bends[bends.Count - 1].pos;<br>&nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; }<br><br>&nbsp; &nbsp; public struct Corner<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; public FloatRect.CornerLabel dir;<br>&nbsp; &nbsp; &nbsp; &nbsp; public Vector2 pos;<br>&nbsp; &nbsp; &nbsp; &nbsp; public Corner(FloatRect.CornerLabel dir, Vector2 pos)<br>&nbsp; &nbsp; &nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this.dir = dir;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this.pos = pos;<br>&nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; }<br><br>&nbsp; &nbsp; public Rope(Room room, Vector2 initA, Vector2 initB, float thickness)<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; this.room = room;<br>&nbsp; &nbsp; &nbsp; &nbsp; A = initA;<br>&nbsp; &nbsp; &nbsp; &nbsp; lastA = initA;<br>&nbsp; &nbsp; &nbsp; &nbsp; B = initB;<br>&nbsp; &nbsp; &nbsp; &nbsp; lastB = initB;<br>&nbsp; &nbsp; &nbsp; &nbsp; totalLength = Vector2.Distance(initA, initB);<br><br>&nbsp; &nbsp; &nbsp; &nbsp; bends = new List&lt;Corner&gt;();<br>&nbsp; &nbsp; &nbsp; &nbsp; corners = new List&lt;Corner&gt;();<br><br>&nbsp; &nbsp; &nbsp; &nbsp; this.thickness = thickness;<br><br>&nbsp; &nbsp; &nbsp; &nbsp; //finds all the corners and stores them in a list. This could also be done locally on the fly, for very large spaces with lots of corners that might be preferable performance-wise.<br>&nbsp; &nbsp; &nbsp; &nbsp; for (int x = 0; x &lt; room.TileWidth; x++)<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (int y = 0; y &lt; room.TileHeight; y++)<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (room.GetTile(x, y).Solid) {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!room.GetTile(x - 1, y).Solid) {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!room.GetTile(x, y - 1).Solid &amp;&amp; !room.GetTile(x - 1, y - 1).Solid)<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; corners.Add(new Corner(FloatRect.CornerLabel.D, room.MiddleOfTile(x, y) + new Vector2(-10f - thickness, -10f - thickness)));<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!room.GetTile(x, y + 1).Solid &amp;&amp; !room.GetTile(x - 1, y + 1).Solid)<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; corners.Add(new Corner(FloatRect.CornerLabel.A, room.MiddleOfTile(x, y) + new Vector2(-10f - thickness, 10f + thickness)));<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!room.GetTile(x + 1, y).Solid) {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!room.GetTile(x, y - 1).Solid &amp;&amp; !room.GetTile(x + 1, y - 1).Solid)<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; corners.Add(new Corner(FloatRect.CornerLabel.C, room.MiddleOfTile(x, y) + new Vector2(10f + thickness, -10f - thickness)));<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!room.GetTile(x, y + 1).Solid &amp;&amp; !room.GetTile(x + 1, y + 1).Solid)<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; corners.Add(new Corner(FloatRect.CornerLabel.B, room.MiddleOfTile(x, y) + new Vector2(10f + thickness, 10f + thickness)));<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br><br>&nbsp; &nbsp; &nbsp; &nbsp; //&nbsp; visualizer = new RopeDebugVisualizer(this);<br><br>&nbsp; &nbsp; }<br><br>&nbsp; &nbsp; public void Reset()<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; bends.Clear();<br>&nbsp; &nbsp; }<br><br>&nbsp; &nbsp; public void Update(Vector2 newA, Vector2 newB)<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; lastA = A;<br>&nbsp; &nbsp; &nbsp; &nbsp; lastB = B;<br>&nbsp; &nbsp; &nbsp; &nbsp; A = newA;<br>&nbsp; &nbsp; &nbsp; &nbsp; B = newB;<br><br>&nbsp; &nbsp; &nbsp; &nbsp; //sweep terrain to add bend points<br>&nbsp; &nbsp; &nbsp; &nbsp; if (bends.Count == 0)<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CollideWithCorners(lastA, A, lastB, B, 0, 0);<br>&nbsp; &nbsp; &nbsp; &nbsp; else {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CollideWithCorners(BConnect, BConnect, lastB, B, bends.Count, 0);<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CollideWithCorners(lastA, A, AConnect, AConnect, 0, 0);<br>&nbsp; &nbsp; &nbsp; &nbsp; }<br><br>&nbsp; &nbsp; &nbsp; &nbsp; //delete bend points where the rope has come free of the corner<br>&nbsp; &nbsp; &nbsp; &nbsp; if (bends.Count &gt; 0) {//could optimize here by making it only check first and last bend point<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&lt;int&gt; deleteBends = new List&lt;int&gt;();<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0; i &lt; bends.Count; i++) {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Vector2 prev = A;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Vector2 nxt = B;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (i &gt; 0) prev = bends[i - 1].pos;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (i &lt; bends.Count - 1) nxt = bends[i + 1].pos;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!DoesLineOverlapCorner(prev, nxt, bends[i])) {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; deleteBends.Add(i);<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (int i = deleteBends.Count - 1; i &gt;= 0; i--)<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bends.RemoveAt(deleteBends[i]);<br>&nbsp; &nbsp; &nbsp; &nbsp; }<br><br>&nbsp; &nbsp; &nbsp; &nbsp; //Calculating new total length of rope<br>&nbsp; &nbsp; &nbsp; &nbsp; if (bends.Count == 0)<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; totalLength = Vector2.Distance(A, B);<br>&nbsp; &nbsp; &nbsp; &nbsp; else {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; totalLength = Vector2.Distance(A, AConnect) + Vector2.Distance(BConnect, B);<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (int i = 1; i &lt; bends.Count; i++)<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; totalLength += Vector2.Distance(bends[i - 1].pos, bends[i].pos);<br>&nbsp; &nbsp; &nbsp; &nbsp; }<br><br><br>&nbsp; &nbsp; &nbsp; &nbsp; if (visualizer != null) visualizer.Update();<br>&nbsp; &nbsp; }<br><br>&nbsp; &nbsp; private void CollideWithCorners(Vector2 la, Vector2 a, Vector2 lb, Vector2 b, int bend, int recursion)<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; Corner? firstCollision = null;<br>&nbsp; &nbsp; &nbsp; &nbsp; float firstCollisionDist = float.MaxValue;<br>&nbsp; &nbsp; &nbsp; &nbsp; foreach (Corner c in corners)<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (DoesLineOverlapCorner(a, b, c)<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; c.pos != la &amp;&amp; c.pos != a &amp;&amp; c.pos != lb &amp;&amp; c.pos != b<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // &amp;&amp; Custom.BetweenLines(c.pos, la, a, lb, b) &amp;&amp; Custom.BetweenLines(c.pos, la, lb, a, b)//old sweep function that would give some false positives<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; (Custom.PointInTriangle(c.pos, a, la, b) || Custom.PointInTriangle(c.pos, a, lb, b) || Custom.PointInTriangle(c.pos, a, la, lb) || Custom.PointInTriangle(c.pos, la, lb, b))<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; Mathf.Abs(Custom.DistanceToLine(c.pos, la, lb)) &lt; Mathf.Abs(firstCollisionDist)) {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; firstCollision = c;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; firstCollisionDist = Custom.DistanceToLine(c.pos, lastA, lastB);<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br><br>&nbsp; &nbsp; &nbsp; &nbsp; if (firstCollision.HasValue) {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Vector2 bendPoint = firstCollision.Value.pos;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bends.Insert(bend, firstCollision.Value);<br><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Vector2 divPoint = Custom.ClosestPointOnLine(la, lb, bendPoint);<br><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CollideWithCorners(divPoint, bendPoint, lb, b, bend + 1, recursion + 1);<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CollideWithCorners(la, a, divPoint, bendPoint, bend, recursion + 1);<br>&nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; }<br><br>&nbsp; &nbsp; public bool DoesLineOverlapCorner(Vector2 l1, Vector2 l2, Corner corner)<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; IntVector2 cornerDir = new IntVector2((corner.dir == FloatRect.CornerLabel.A || corner.dir == FloatRect.CornerLabel.D) ? -1 : 1,<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (corner.dir == FloatRect.CornerLabel.A || corner.dir == FloatRect.CornerLabel.B) ? 1 : -1);<br><br>&nbsp; &nbsp; &nbsp; &nbsp; if (l1.y != l2.y)<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if ((cornerDir.x &lt; 0 &amp;&amp; (Custom.HorizontalCrossPoint(l1, l2, corner.pos.y).x &lt; corner.pos.x))<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; || (cornerDir.x &gt; 0 &amp;&amp; (Custom.HorizontalCrossPoint(l1, l2, corner.pos.y).x &gt; corner.pos.x)))<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;<br><br>&nbsp; &nbsp; &nbsp; &nbsp; if (l1.x != l2.x)<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if ((cornerDir.y &lt; 0 &amp;&amp; (Custom.VerticalCrossPoint(l1, l2, corner.pos.x).y &lt; corner.pos.y))<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; || (cornerDir.y &gt; 0 &amp;&amp; (Custom.VerticalCrossPoint(l1, l2, corner.pos.x).y &gt; corner.pos.y)))<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;<br><br>&nbsp; &nbsp; &nbsp; &nbsp; return true;<br>&nbsp; &nbsp; }<br><br>}<br></div>